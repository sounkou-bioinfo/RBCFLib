---
output: github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%"
)
```

# RBCFLIB

**RBCFLib** provides a minimalist and GWAS-VCF centric R wrapper for `htslib` and `bcftools`, enabling efficient manipulation of BCF/VCF genomic data files directly within R. The package includes bundled bcftools source code that is compiled during installation, then executes bcftools commands as optimized subprocesses through a C interface that handles piping, error capture, and process management. Some other convenience functions for common tasks are also provided including a custom index re-implementing the [`Seqminer2`](https://github.com/zhanxw/seqminer) single chromosome index format for fast random access to records.

Originally this project focused solely on lightweight bcftools wrapping for GWAS-VCF workflows; over time it added score plugin helpers, a custom VBI index + CGRanges integration, and finally the embedded archived low-level `rbcf` bindings.

## Installation

### Requirements

-   R
-   Unix-like OS (Linux, macOS) or Windows WSL2
-   cmake (for building bundled SuiteSparse/CHOLMOD used by BCFToolsPGS)
``` r

# to install from r-universe

install.packages('RBCFLib', repos = c('https://sounkou-bioinfo.r-universe.dev'))

# install the developement version from github

devtools::install_github("sounkou-bioinfo/RBCFLib@develop")
```

## BCFTools Wrapper

RBCFLib provides direct access to the full bcftools CLI from R, supporting all bcftools features and plugins with high performance and robust error handling.

-   **BCFTools Executable Wrapper:** Execute any `bcftools` command directly from R using `BCFToolsRun()`.
-   **Piping and Pipeline Support:** Create processing workflows within R using `BCFToolsPipeline()`, which chains multiple bcftools commands in efficient pipelines with automatic process management and piping in optimized C code. The chain needs to be valid bcftools commands.
-   **Version Information:** Retrieve `htslib` and `bcftools` library versions using `HTSLibVersion()` and `BCFToolsVersion()`.
-   **Utility Functions:** Access the path to the bundled `bcftools` executable via `BCFToolsBinaryPath()` and the plugins installation directory with `BCFTOOLS_PLUGINS()`.

**Example:**


```{r setup, message=FALSE}
library(RBCFLib)
```

```{r bcftools-Pipeline-examples}
BCFToolsVersion() |> print()
vcfFile <- system.file("exdata", "imputed.gt.vcf.gz", package = "RBCFLib")
results <- BCFToolsRun("+vcf2table", vcfFile)
print(results$stdout |> head(10))
results <- BCFToolsPipeline(
    "view", c("-r", "chr21", "-Ob", vcfFile),
    "view", c("--no-version"),
    "query", c("-H","-f", "%CHROM\t%POS\t%REF\t%ALT\n")
    )
print(results$stdout |> head(10))
```

## BCFTools Score Plugins

RBCFLib provides R wrappers for the bcftools score plugin suite, enabling GWAS-VCF conversion and polygenic score analysis:

-   **`BCFToolsMunge`**: Convert summary statistics to GWAS-VCF format
-   **`BCFToolsScore`**: Compute polygenic scores using genotype data and weights
-   **`BCFToolsLiftover`**: Convert variants between genome assemblies
-   **`BCFToolsMetal`**: Perform meta-analysis on GWAS-VCF files
-   **`BCFToolsPGS`**: Compute polygenic score loadings (bundled SuiteSparse/CHOLMOD included)
-   **`BCFToolsBLUP`**: Compute BLUP

For more details, see the [BCFTools Score documentation](https://github.com/freeseek/score).

## VBI Indexes and CGRanges

RBCFLib includes a fast, custom index format (VBI) that uses a format similar to [Seqminer2](https://github.com/zhanxw/seqminer), but with additional [cgranges](https://github.com/lh3/cgranges/) support when loading the index as C-level pointers. This enables rapid random access and region queries on large VCF/BCF files. The cgranges library is integrated to provide fast overlap retrieval of BCF/VCF ranges from VBI-indexed files or for basic range-based tests.

### CGRanges Functions

Create and query genomic intervals using an efficient interval tree data structure:

- `CGRangesCreate()`: Create a new CGRanges object
- `CGRangesAdd()`: Add genomic intervals
- `CGRangesIndex()`: Build the interval tree index
- `CGRangesOverlap()`: Find overlapping intervals
- `CGRangesOverlapVec()`: Vectorized overlap queries
- `CGRangesExtractByIndex()`: Extract intervals by index
- `CGRangesDestroy()`: Free memory

**Example:**

```{r cgranges-example}
cr <- CGRangesCreate()
CGRangesAdd(cr, "chr1", 10, 20, 1)
CGRangesAdd(cr, "chr1", 15, 25, 2) 
CGRangesAdd(cr, "chr2", 5, 15, 3)
CGRangesIndex(cr)

# Find overlapping intervals
hits <- CGRangesOverlap(cr, "chr1", 18, 22)
print("Overlapping intervals:")
print(hits)

# Extract intervals by index
extracted <- CGRangesExtractByIndex(cr, c(1, 2, 3))
print("Extracted intervals:")
print(extracted)

CGRangesDestroy(cr)
```

### VBI Index Functions

The VBI (Variant Binary Index) system provides fast random access to variants in VCF/BCF files:

- `VBIIndex()`: Create a VBI index for a VCF/BCF file
- `VBIIndexLoad()`: Load a VBI index file as an external pointer
- `VBIExtractRanges()`: Extract variant ranges from a VBI index
- `VBIPrintIndex()`: Print lines from a VBI index for debugging
- `VBIQueryRange()`: Query VBI index by genomic region (linear scan)
- `VBIQueryByIndices()`: Query VBI index by variant index range
- `VBIQueryRegion()`: Query VBI index by region with INFO/FORMAT/genotype options
- `VBIQueryRegionCGRanges()`: Query VBI index by region using CGRanges (fast interval tree)
- `VBIIndexMemoryUsage()`: Get memory usage statistics

**Example:**

```{r vbi-example}
vcfFile <- system.file("exdata", "imputed.gt.vcf.gz", package = "RBCFLib")
vbiFile <- tempfile(fileext = ".vbi")

# Create VBI index
VBIIndex(vcfFile, vbiFile)

# Load VCF with VBI integration
vcf_ctx <- VCFLoad(vcfFile, vbiFile)

# Get basic info
print(paste("Samples:", VBINSamples(vcf_ctx)))

# Query by variant index range (1-based, inclusive)
hits_by_index <- VBIQueryByIndices(vcf_ctx, 1, 3)
print("First 3 variants by index:")
print(hits_by_index)
# header
header <- VCFHeaderInfo(vcfFile)
str(header)
# header from VBI context
str(VBIPrintHeaderMetadata(vcf_ctx))
# Query by genomic region with basic fields
hits_region <- VBIQueryRegion(vcf_ctx, "chr21:5030082-5030356")
print(hits_region)

# Query by genomic region using CGRanges (fast interval tree)
hits_cgranges <- VBIQueryRegionCGRanges(vcf_ctx, "chr21:5030082-5030356")
print(hits_cgranges)

# Verify equality between regular and CGRanges queries
print(paste("Results are identical:", identical(hits_region, hits_cgranges)))

# Query by genomic region with INFO fields
hits_with_info <- VBIQueryRegion(vcf_ctx, "chr21:5030082-5030356", include_info = TRUE)
print(hits_with_info[1:3, ])  # Show first 3 rows only

# Query with genotype data
hits_with_gt <- VBIQueryRegion(vcf_ctx, "chr21:5030082-5030356", include_genotypes = TRUE)
print(hits_with_gt[1:2, c("chrom", "pos", "ref", "alt", "GT")])

# Query with all fields (INFO, FORMAT, and genotypes)
hits_all <- VBIQueryRegion(vcf_ctx, "chr21:5030082-5030356", 
                          include_info = TRUE, 
                          include_format = TRUE, 
                          include_genotypes = TRUE)
print(colnames(hits_all))

# Load index as external pointer for direct access
vbi_ptr <- VBIIndexLoad(vbiFile)

# Extract variant ranges
ranges <- VBIExtractRanges(vbi_ptr, 5)
print(ranges)

# Check memory usage
mem_usage <- VBIIndexMemoryUsage(vbi_ptr)
print(paste("VBI memory usage:", round(sum(unlist(mem_usage)) / 1e6, 3), "MB"))

# Clean up
unlink(vbiFile)
```

### Performance Optimization

The VBI system includes optimized query methods for different use cases:

- **`VBIQueryRegion()`**: Standard region queries using linear scan through the index
- **`VBIQueryRegionCGRanges()`**: Optimized region queries using interval tree (cgranges) for faster lookups
- **`VBIQueryByIndices()`**: Direct access by variant index for sequential access patterns

The cgranges-optimized queries can provide significant performance improvements for complex interval queries, especially with large datasets. The optimization eliminates redundant file I/O operations and leverages efficient interval tree data structures.

## Embedded original `rbcf` low-level API

This repository now embeds (with minor updates for htslib 1.21 and current R API) the archived low-level VCF/BCF binding code authored by Pierre Lindenbaum (original project: lindenb/rbcf). These functions expose opaque external pointer contexts and direct accessor helpers. They coexist with the higher-level bcftools process wrappers, letting you mix streaming (low-level) and pipeline (bcftools) workflows. See tinytests and man pages for concise examples. Attribution: Pierre Lindenbaum PhD (@yokofakun).

- Open / iterate / write: `BCFOpen()`, `BCFNext()`, `BCFNewWriter()`, `BCFWriteVariant()`, `BCFClose()`
- Header & samples: `BCFNSamples()`, `BCFSamples()`, `BCFSampleAt()`, `BCFSample2Index()`, `BCFChromosomes()`, `BCFDictionary()`
- Variant access: `VariantPos()`, `VariantAlleles()`, `VariantReference()`, `VariantAltAlleles()`, `VariantHasQual()`, `VariantQual()`, `VariantFilters()` etc.
- INFO / FORMAT: `VariantHasAttribute()`, `VariantStringAttribute()`, `VariantIntAttribute()`, `VariantFloatAttribute()`, `VariantFlagAttribute()`
- Genotypes: `VariantGenotype()`, `VariantGenotypesAlleleIdx0()`, `GenotypePloidy()`, `GenotypeHomRef()`, `GenotypeHet()` â€¦
- Annotations: `VariantVep()`, `VariantSnpEff()`

### Low-level examples (adapted from original `rbcf`)

All examples use packaged example data via `system.file("exdata", ..., package = "RBCFLib")`.

#### Versions
```{r low_versions}
library(RBCFLib)
HTSLibVersion()
BCFToolsVersion()
```

#### Open and close a VCF (no index required)
```{r low_open_close}
vcf <- system.file("exdata","rotavirus_rf.01.vcf", package="RBCFLib")
fp <- BCFOpen(vcf, requireIndex = FALSE)
stopifnot(!is.null(fp))
BCFClose(fp)
```

#### List INFO / FORMAT / FILTER header fields
```{r low_header_fields}
fp <- BCFOpen(vcf, requireIndex = FALSE)
head(BCFInfos(fp))      # show first rows
head(BCFFormats(fp))
BCFFilters(fp)
BCFClose(fp)
```

#### Samples and dictionary
```{r low_samples_dict}
fp <- BCFOpen(vcf, requireIndex = FALSE)
BCFNSamples(fp)
BCFSamples(fp)
BCFSampleAt(fp, 1)
BCFSample2Index(fp, c("S1","S2","missing"))
BCFDictionary(fp)
BCFClose(fp)
```

#### Indexed chromosomes / contigs
```{r low_indexed_chrom}
vcf_gz <- system.file("exdata","rotavirus_rf.02.vcf.gz", package="RBCFLib")
fp <- BCFOpen(vcf_gz)
BCFChromosomes(fp)
BCFClose(fp)
```

#### Scan all variants (count)
```{r low_scan_count}
count_variants <- function(f, requireIndex = FALSE) {
  fp <- BCFOpen(f, requireIndex=requireIndex)
  if(is.null(fp)) return(NA_integer_)
  n <- 0L
  while(!is.null(vc <- BCFNext(fp))) n <- n + 1L
  BCFClose(fp); n
}
count_variants(vcf)
```

#### Predicate scan (e.g. count PASS SNPs)
```{r low_predicate_scan}
fp <- BCFOpen(system.file("exdata","gnomad.exomes.r2.0.1.sites.bcf", package="RBCFLib"))
pass_snps <- 0L
while(!is.null(vc <- BCFNext(fp))) {
  if(length(VariantFilters(vc))==0L && VariantAlleles(vc)[1] %in% c("A","C","G","T") &&
     all(nchar(VariantAlleles(vc))==1L)) pass_snps <- pass_snps + 1L
}
BCFClose(fp)
pass_snps
```

#### Query regions
```{r low_query_regions}
fp <- BCFOpen(vcf_gz)
count_RF03 <- NA_integer_
if(BCFQuery(fp, "RF03")) {
  k <- 0L
  while(!is.null(vc <- BCFNext(fp))) k <- k + 1L
  count_RF03 <- k
}
# window query (sets iterator)
BCFQuery(fp, "RF03:2000-3000")
BCFClose(fp)
count_RF03
```

#### Find a specific variant & access INFO attributes
```{r low_find_variant}
find_variant <- function(f, region) {
  fp <- BCFOpen(f)
  on.exit(BCFClose(fp))
  if(!BCFQuery(fp, region)) return(NULL)
  BCFNext(fp)
}
site_bcf <- system.file("exdata","gnomad.exomes.r2.0.1.sites.bcf", package="RBCFLib")
vc_site <- find_variant(site_bcf, "1:905608-905608")
if(!is.null(vc_site) && VariantHasAttribute(vc_site, "AF_POPMAX")) {
  VariantFloatAttribute(vc_site, "AF_POPMAX")
}
```

#### VEP / SnpEff annotations
```{r low_annotations}
# VEP (CSQ)
vc_vep <- find_variant(site_bcf, "1:905608-905608")
if(!is.null(vc_vep) && VariantHasAttribute(vc_vep, "CSQ")) {
  head(VariantVep(vc_vep))
}
# SnpEff (ANN)
ann_vcf <- system.file("exdata","rotavirus_rf.ann.vcf.gz", package="RBCFLib")
vc_ann <- find_variant(ann_vcf, "RF03:2150-2150")
if(!is.null(vc_ann) && VariantHasAttribute(vc_ann, "ANN")) {
  head(VariantSnpEff(vc_ann))
}
```

#### Genotype access (single sample)
```{r low_genotype_single}
geno_bcf <- system.file("exdata","1000G.ALL.2of4intersection.20100804.genotypes.bcf", package="RBCFLib")
vc_gt <- find_variant(geno_bcf, "1:10583-10583")
if(!is.null(vc_gt)) {
  ns <- VariantNSamples(vc_gt)
  gt10 <- VariantGenotype(vc_gt, 10)
  list(sample=GenotypeSample(gt10), ploidy=GenotypePloidy(gt10), het=GenotypeHet(gt10))
}
```

#### Vectorized genotype attributes
```{r low_genotype_vector}
if(!is.null(vc_gt)) {
  dp <- VariantGenotypesIntAttribute(vc_gt, "DP")
  gt_idx <- VariantGenotypesAlleleIdx0(vc_gt)
  gt_ref_counts <- VariantGenotypesAlleleCounts(vc_gt, 0)
  gt_str <- VariantGenotypesAlleleStrings(vc_gt)
  list(DP=head(dp), GT_IDX=head(gt_idx), REF_COUNTS=head(gt_ref_counts), GT_STR=head(gt_str))
}
```

#### Write filtered variants to stdout
```{r low_write_filtered}
fp_in <- BCFOpen(vcf, requireIndex=FALSE)
out <- BCFNewWriter(fp_in, "-")
while(!is.null(v <- BCFNext(fp_in))) {
  if(VariantPos(v) %% 10 == 0) BCFWriteVariant(out, v)
}
BCFClose(fp_in); BCFClose(out)
```




## Related Projects

-   [gwasvcf](https://github.com/MRCIEU/gwasvcf): R package for manipulating GWAS summary statistics in VCF format.
-   [MungeSumstats](https://github.com/Al-Murphy/MungeSumstats): R package for standardizing GWAS summary statistics.
-   [Seqminer2](https://github.com/zhanxw/seqminer): Fast random access to BCF/VCF files using a custom index format.
-   [vcfppR](https://github.com/Zilong-Li/vcfppR): Ultra-fast BCF/VCF I/O in R using Rcpp.



## Future Directions

-   RgwasVCF: Advanced GWAS-VCF manipulation and analysis with convenient interfaces, depending on RBCFLib.
-   RArrowBCF: High-performance BCF/VCF I/O using Apache Arrow for in-memory data representation.
  

## TODO





- [ ] Use the bundled hmmap plugin ?